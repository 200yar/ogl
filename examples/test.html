<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimal-ui, viewport-fit=cover, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no">

    <title>OGL WebGL Framework</title>
    <link href="assets/main.css" rel="stylesheet">
</head>
<body>
    <script type="module">
        import {Renderer, Geometry, Program, Texture, Transform, Mesh, Camera, RenderTarget, Vec3} from '../src/OGL.js';
        import BasicShader from './shaders/BasicShader.js';
        import ClipShader from './shaders/ClipShader.js';

        {
            const renderer = new Renderer({
                width: 400,
                height: 400,
//                alpha: true,
            });
            const gl = renderer.gl;
            document.body.appendChild(gl.canvas);
            gl.clearColor(1, 1, 1, 1);




            const geometry = new Geometry(gl, {
                position: {size: 3, data: new Float32Array([-0.5, 0.5, 0, 0.5, 0.5, 0, -0.5, -0.5, 0, 0.5, -0.5, 0])},
                uv: {size: 2, data: new Float32Array([0, 1, 1, 1, 0, 0, 1, 0])},
                index: {data: new Uint16Array([0, 2, 1, 1, 2, 3])},
                offset: {instanced: true, size: 3, data: new Float32Array([0, 0, 0, 1, 1, 1, -1, -1, 1])},
            });

            const program = new Program(gl, {
                vertexShader: BasicShader.vertex,
                fragmentShader: BasicShader.fragment,
                uniforms: {
                    uTime: {value: 0},
                    tMap: {value: new Texture(gl)},
                },
                cullFace: null, // gl.BACK is default
                // transparent: true,
            });

            let img = new Image();
            img.onload = () => program.uniforms.tMap.value.image = img;
            img.src = 'assets/uv.jpg';

            const scene = new Transform(gl);

            const shape = new Mesh(gl, {geometry, program});
            shape.scale.x = -1;
            shape.setParent(scene);

            const camera = new Camera(gl, {
                near: 0.1,
                far: 100,
                fov: 15,
                aspect: gl.canvas.width / gl.canvas.height,
            });
            camera.position.z = 10;
            camera.target = new Vec3([0, 0, 0]);





            const quadGeometry = new Geometry(gl, {
                position: {size: 3, data: new Float32Array([-0.5, 0.5, 0, 0.5, 0.5, 0, -0.5, -0.5, 0, 0.5, -0.5, 0])},
                uv: {size: 2, data: new Float32Array([0, 1, 1, 1, 0, 0, 1, 0])},
                index: {data: new Uint16Array([0, 2, 1, 1, 2, 3])},
            });
            const rtt = new RenderTarget(gl);

            const clipProgram = new Program(gl, {
                vertexShader: ClipShader.vertex,
                fragmentShader: ClipShader.fragment,
                uniforms: {
                    tMap: {value: rtt.texture},
                },
                // cullFace: null, // gl.BACK is default
                // transparent: true,
            });
            const quad = new Mesh(gl, {geometry: quadGeometry, program: clipProgram});


            // Framebuffer needs one frame apparently - for rendering in one frame
            // setTimeout(() => {
            requestAnimationFrame(update);
            // }, 0);

            function update(t) {
                requestAnimationFrame(update);

                program.uniforms.uTime.value = t * 0.001;
                camera.target.y = 0;
                shape.rotation.y += 0.01;
                camera.position.y = Math.sin(t * 0.001) * 5;
                camera.lookAt(camera.target);

//                gl.clearColor(0, 0, 0, 1);
                renderer.render({scene, camera, target: rtt});
                // renderer.render({scene, camera});

                // gl.clearColor(1, 1, 1, 1);
                renderer.render({scene: quad});
            }
        }

    </script>
</body>
</html>